
组件化就是将一个工程分解为各个独立的组件，按某种方式组成一个完整逻辑的工程

产生原因：不断迭代更新，业务越来越多，开发人员组件增多

## 问题
- 耦合严重
	老模块依赖，修改bug，花费时间、精力
- 编译速度慢
	业务越来越多，项目越来越大，使用组件化开发配合二进制化，提高整个项目的编译时间
- 测试不独立
	各自开发自己的模块，对自己的模块进行测试，但如果主工程存在一个bug，导致工程编译不了，无法测试
- 难以使用擅长的设计模式
	如果项目主要使用MVVM，而你只会使用MVC，如果设计模式按功能模块进行划分，则无法使用MVC套用MVVM
...

## 组件化优势
- 组件独立
	可以独立编写我们的模块，独立编译不用等待主工程长时间的编译，不用担心各种非自己模块中的bug而无法测试
- 资源重用
	项目中各种分类、宏定义、基础配置等基础代码，以及轮播器、选项卡等功能性自定义UI组件，我们只要以pod库的形式导入到工程中实现重用
- 高效迭代
	如果要增加、删除某些模块，只需要引入或删除对应的库，就可以增加或移除某个模块，不会影响宿主工程的正常运行
	把业务、功能、基础模块拆分成组件后，可以采用静态库打包，framework库的形式二进制化组件，大大提高我们的编译速度

## 组件化分析
	1.组件划分
		- 基础组件
			基本配置（常量、宏），分类（系统类扩展），网络（AFN、SDWebImage封装），工具（日期时间处理、文件处理，设备信息等）
		- 功能组件
			控件（轮播器、选项菜单、图文菜单等），功能（断点续传、音频处理等）
		- 业务组件
			业务一（子业务-、子业务二...）
			业务二（子业务-、子业务二...）

	2.组件层次关系
		1.基础组件和功能组件处同一层次
		2.功能组件不该依赖基础组件，如果用到某些代码，最好是把代码拷贝到功能组件中
		3.各组件内部的组件间也不该有依赖关系
		4.在不产生依赖关系的前提下如果需要使用其他组件的内容，需要做好**组件间通讯**

	3.组件的存在形式
		内部：根据设计模式划分文件夹结构
		对外：以pod库的形式存在
		测试：单独的测试工程，可以通过创建pod模版库的形式，直接拥有测试工程

	4.以cocoapods的形式安装各组件
		业务组件 依赖 基础组件、功能组件
		业务组件 以pod库的形式安装到 宿主工程 中

	5.组件间通讯
		三大组件内部不能有依赖关系，但确实有些时候一个组件内部发生的事件需要告诉其他组件，或调用某些组件的服务
		一种方式：中间件
			组件将内部发生的变化告诉中间件，中间件通知其他组件。组件把各自的服务给中间件，需要对应服务的组件就会中间件拿，这样组件就不会产生依赖关系

## 分离组件的难点-解耦
	两种情况：	1.组件里依赖其他公共功能
					直接copy代码，好处是不会有额外的依赖。可以把依赖的代码做成一个pod库，然后依赖这个库即可
				2.组件内部需要对接某个服务
					比如我们组件内部涉及到加载网络图片SDWebImage，虽然我们可以在使用远程私有索引库的时候添加依赖，我们在下载私有库里面组件的时候可以将SDWebImage一并集成到我们的宿主工程中，如果公司用的不是SDWebIamge呢？
					所以我们可以使用block或代理把这部分职责丢出去，那我们就可以自由的选择需要使用的第三方框架或公司内部框架


## Router

1.单例 dispath_once

// http://target/action?param1=name1&param2=name2
2.外部调用 (id)openUrl:	(id)openUrl: handler:
   2.1 url.query 分割字符串
   2.2 解析字符串 obj : key 放到dictionary中
   2.3 url.path 判断是否是 native
   2.4 是 native 则 return
   2.5 block 有则放入 dictionary

3.调用 performTarget: action: param:
   3.1 target: NSString -> Class -> NSObject
   3.2 action: NSString -> SEL
   3.3 判断是否能响应方法 [target respondsToSelector:action]
   3.4 通过对象调用指定方法 safePerformAction: target: param:
   3.5 NSMethodSignature 方法签名
   3.6 获取方法的返回值地址 [methodSig methodReturnType]
   3.7 单独处理返回值为基本变量 NSInvocation，setArgument:，setTarget:，setSelector: => [invocation invoke] ,return
   3.8 return [target performSelector:action withObject:target withObject:para]
